<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Mandelbrot set</title>
		<link rel="stylesheet" type="text/css" href="./main.css">
		<script defer src="./lib/three.js/three.r113.js"></script>
		<script type="x-shader/x-vertex" id="shader_vertex">
			attribute float vertex_z_r;
			attribute float vertex_z_i;
			
			// varyings get passed to the fragment shader.
			varying float c_r;
			varying float c_i;
			
			void main() {
				// Say what the varying values are.
				c_r = vertex_z_r;
				c_i = vertex_z_i;
				
				// Have to say what the position is:
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="shader_fragment">
			// Varyings get declared in both vertex and fragment shaders:
			varying float c_r;
			varying float c_i;
			
			uniform int max_iterations;
			
			// Defining the lower and upper ends of the colour scale:
			#define r_value 0.8
			
			#define g_value 0.8
			
			#define b_value 1.0
			
			void main() {
				float r;
				float g;
				float b;
				float t;
				float w_r;
				float w_i;
				float u;
				float v;
					
				w_r = 0.0;
				w_i = 0.0;
				
				// Color if series stays converged:
				r = 1.0;
				g = 1.0;
				b = 1.0;
				
				for (int i = 0; i < 65536; i++) {
					u = w_r;
					v = w_i;
					
					w_r = u*u - v*v + c_r;
					w_i = 2.0*u*v + c_i;
					
					if (w_r*w_r + w_i*w_i > 4.0) {
						// Diverged: make a pretty colour.
						t = float(i)/float(max_iterations);
						
						r = t*r_value;
						g = t*g_value;
						b = t*b_value;
						
						break;
					}
					
					if (i >= max_iterations) {
						break;
					}
				}
				
				gl_FragColor = vec4(r, g, b, 1);
			}
		</script>
		<script defer src="./main.js"></script>
	</head>
	<body>
		<div class="view" id="gl-view">
		</div>
	</body>
</html>